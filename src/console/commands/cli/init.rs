use std::path::{Path, PathBuf};

use crate::cli::config_parser::{
    AiConfig, AiProviderType, AppType, ConfigBuilder, DomainConfig, ProxyConfig, ProxyType,
    SslMode, StackerConfig,
};
use crate::cli::detector::{detect_project, RealFileSystem};
use crate::cli::error::CliError;
use crate::console::commands::CallableTrait;

/// Default config filename generated by `stacker init`.
pub const DEFAULT_CONFIG_FILE: &str = "stacker.yml";

/// `stacker init [--type static|node|python|rust|go|php] [--with-proxy] [--with-ai]`
///
/// Detects the project type in the current directory and generates
/// a `stacker.yml` configuration file with sensible defaults.
pub struct InitCommand {
    pub app_type: Option<String>,
    pub with_proxy: bool,
    pub with_ai: bool,
}

impl InitCommand {
    pub fn new(app_type: Option<String>, with_proxy: bool, with_ai: bool) -> Self {
        Self {
            app_type,
            with_proxy,
            with_ai,
        }
    }
}

/// Parse an app type string (e.g. "node", "static") into `AppType`.
fn parse_app_type(s: &str) -> Result<AppType, CliError> {
    let json = format!("\"{}\"", s.to_lowercase());
    serde_json::from_str::<AppType>(&json).map_err(|_| {
        CliError::ConfigValidation(format!(
            "Unknown app type '{}'. Valid types: static, node, python, rust, go, php, custom",
            s
        ))
    })
}

/// Generate a `stacker.yml` config in the target directory.
///
/// This is extracted as a standalone function for testability — the
/// `InitCommand::call()` delegates here with `std::env::current_dir()`.
pub fn generate_config(
    project_dir: &Path,
    app_type_override: Option<&str>,
    with_proxy: bool,
    with_ai: bool,
) -> Result<PathBuf, CliError> {
    let config_path = project_dir.join(DEFAULT_CONFIG_FILE);

    // Don't overwrite existing config
    if config_path.exists() {
        return Err(CliError::ConfigValidation(format!(
            "{} already exists. Remove it first or edit it directly.",
            DEFAULT_CONFIG_FILE
        )));
    }

    // Determine app type: flag override > detection > default (static)
    let app_type = if let Some(type_str) = app_type_override {
        parse_app_type(type_str)?
    } else {
        let fs = RealFileSystem;
        let detection = detect_project(project_dir, &fs);
        detection.app_type
    };

    // Derive project name from directory name
    let project_name = project_dir
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("my-app")
        .to_string();

    // Build config
    let mut builder = ConfigBuilder::new()
        .name(&project_name)
        .version("0.1.0")
        .app_type(app_type)
        .app_path(".");

    if with_proxy {
        builder = builder.proxy(ProxyConfig {
            proxy_type: ProxyType::Nginx,
            domains: vec![DomainConfig {
                domain: format!("{}.localhost", project_name),
                ssl: SslMode::Auto,
                upstream: "app:80".to_string(),
            }],
            ..ProxyConfig::default()
        });
    }

    if with_ai {
        builder = builder.ai(AiConfig {
            enabled: true,
            provider: AiProviderType::Ollama,
            model: Some("llama3".to_string()),
            ..AiConfig::default()
        });
    }

    let config = builder.build()?;

    // Serialize to YAML
    let yaml = serde_yaml::to_string(&config)
        .map_err(|e| CliError::GeneratorError(format!("Failed to serialize config: {e}")))?;

    // Write with a header comment
    let content = format!(
        "# Stacker configuration — generated by `stacker init`\n\
         # Docs: https://docs.try.direct/stacker\n\
         \n\
         {yaml}"
    );

    std::fs::write(&config_path, &content)?;

    Ok(config_path)
}

impl CallableTrait for InitCommand {
    fn call(&self) -> Result<(), Box<dyn std::error::Error>> {
        let project_dir = std::env::current_dir()?;

        let config_path = generate_config(
            &project_dir,
            self.app_type.as_deref(),
            self.with_proxy,
            self.with_ai,
        )?;

        eprintln!("✓ Created {}", config_path.display());

        // Verify the generated file is parseable
        let config = StackerConfig::from_file(&config_path)?;
        eprintln!("  Project: {} ({})", config.name, config.app.app_type);

        if self.with_proxy {
            eprintln!("  Proxy: enabled (nginx)");
        }
        if self.with_ai {
            eprintln!("  AI: enabled (ollama)");
        }

        eprintln!("\nNext steps:");
        eprintln!("  stacker config validate   # Check configuration");
        eprintln!("  stacker deploy --target local --dry-run   # Preview deployment");
        eprintln!("  stacker deploy --target local   # Deploy locally");

        Ok(())
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// Tests
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn setup_dir_with_files(files: &[&str]) -> TempDir {
        let dir = TempDir::new().unwrap();
        for f in files {
            std::fs::write(dir.path().join(f), "").unwrap();
        }
        dir
    }

    #[test]
    fn test_init_static_project_creates_config() {
        let dir = setup_dir_with_files(&["index.html"]);
        let result = generate_config(dir.path(), None, false, false);
        assert!(result.is_ok());

        let path = result.unwrap();
        assert!(path.exists());

        let config = StackerConfig::from_file(&path).unwrap();
        assert_eq!(config.app.app_type, AppType::Static);
    }

    #[test]
    fn test_init_node_project_detects_correctly() {
        let dir = setup_dir_with_files(&["package.json"]);
        let result = generate_config(dir.path(), None, false, false);
        assert!(result.is_ok());

        let config = StackerConfig::from_file(&result.unwrap()).unwrap();
        assert_eq!(config.app.app_type, AppType::Node);
    }

    #[test]
    fn test_init_type_flag_overrides_detection() {
        // Dir has package.json (Node) but flag says python
        let dir = setup_dir_with_files(&["package.json"]);
        let result = generate_config(dir.path(), Some("python"), false, false);
        assert!(result.is_ok());

        let config = StackerConfig::from_file(&result.unwrap()).unwrap();
        assert_eq!(config.app.app_type, AppType::Python);
    }

    #[test]
    fn test_init_with_proxy_flag_adds_section() {
        let dir = setup_dir_with_files(&["index.html"]);
        let result = generate_config(dir.path(), None, true, false);
        assert!(result.is_ok());

        let config = StackerConfig::from_file(&result.unwrap()).unwrap();
        assert_eq!(config.proxy.proxy_type, ProxyType::Nginx);
        assert!(!config.proxy.domains.is_empty());
        assert!(config.proxy.domains[0].domain.contains("localhost"));
    }

    #[test]
    fn test_init_with_ai_flag_adds_section() {
        let dir = setup_dir_with_files(&["index.html"]);
        let result = generate_config(dir.path(), None, false, true);
        assert!(result.is_ok());

        let config = StackerConfig::from_file(&result.unwrap()).unwrap();
        assert!(config.ai.enabled);
        assert_eq!(config.ai.provider, AiProviderType::Ollama);
    }

    #[test]
    fn test_init_does_not_overwrite_existing() {
        let dir = setup_dir_with_files(&["index.html", DEFAULT_CONFIG_FILE]);
        let result = generate_config(dir.path(), None, false, false);
        assert!(result.is_err());

        let err = format!("{}", result.unwrap_err());
        assert!(err.contains("already exists"));
    }

    #[test]
    fn test_init_output_parses_as_valid_config() {
        let dir = setup_dir_with_files(&["index.html"]);
        let path = generate_config(dir.path(), None, false, false).unwrap();

        // Must be parseable
        let result = StackerConfig::from_file(&path);
        assert!(result.is_ok());
    }

    #[test]
    fn test_init_empty_dir_defaults_to_custom() {
        let dir = TempDir::new().unwrap();
        let result = generate_config(dir.path(), None, false, false);
        assert!(result.is_ok());

        let config = StackerConfig::from_file(&result.unwrap()).unwrap();
        // Empty dir with no recognized files → Custom (detector default)
        assert_eq!(config.app.app_type, AppType::Custom);
    }

    #[test]
    fn test_parse_app_type_valid() {
        assert_eq!(parse_app_type("static").unwrap(), AppType::Static);
        assert_eq!(parse_app_type("node").unwrap(), AppType::Node);
        assert_eq!(parse_app_type("Python").unwrap(), AppType::Python);
        assert_eq!(parse_app_type("RUST").unwrap(), AppType::Rust);
    }

    #[test]
    fn test_parse_app_type_invalid() {
        let result = parse_app_type("java");
        assert!(result.is_err());
        let err = format!("{}", result.unwrap_err());
        assert!(err.contains("Unknown app type"));
    }
}
